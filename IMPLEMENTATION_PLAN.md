# Implementation Plan for ObjC Direct Nil-Check Thunk Optimization

## Overview
This document outlines the implementation plan for the RFC: "Optimizing Code Size of objc_direct by Exposing Function Symbols and Moving Nil Checks to Thunks"

## Current Status
✅ **Commit 1: Infrastructure** (COMPLETED)
- Added `-fobjc-nil-check-thunk` compiler flag
- Added `ObjCNilCheckThunk` CodeGenOption
- Created test files that document current and expected behavior
- Tests currently pass (flag is recognized but ignored)

✅ **Phase 1: Method Implementation Generation** (COMPLETED)
✅ **Phase 2: Call Site Analysis** (COMPLETED)
✅ **Phase 2.5: Linkage Fix** (COMPLETED)
- Corrected linkage to use ExternalLinkage for implementations

## Implementation Phases

### Phase 1: Modify Method Implementation Generation ✅ **COMPLETED**
**Files modified:**
- `/home/peterrong/llvm-project/clang/include/clang/AST/DeclObjC.h`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CodeGenModule.h`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjC.cpp`
- `/home/peterrong/llvm-project/clang/test/CodeGenObjC/direct-method-nil-check-thunk-varargs.m` (new test)

**Changes implemented:**

1. **Added eligibility check in ObjCMethodDecl** (DeclObjC.h):
   ```cpp
   bool canHaveNilCheckThunk() const {
     // Only direct methods that are not variadic are eligible
     return isDirectMethod() && !isVariadic();
   }
   ```

2. **Added optimization check in CodeGenModule** (CodeGenModule.h):
   ```cpp
   bool shouldHaveNilCheckThunk(const ObjCMethodDecl *OMD) const {
     // Requires: NeXT runtime family + flag enabled + method is eligible
     return getLangOpts().ObjCRuntime.isNeXTFamily() &&
            getCodeGenOpts().ObjCNilCheckThunk && OMD->canHaveNilCheckThunk();
   }
   ```

3. **Refactored symbol name generation** (CGObjCRuntime.h/cpp):
   - Merged two `getSymbolNameForMethod()` overloads with default parameter `includePrefixByte = true`
   - Allows removing `\01` prefix when optimization is enabled

4. **Modified GenerateDirectMethod()** (CGObjCMac.cpp):
   - Linkage: Always uses `ExternalLinkage` (makes implementation publicly visible)
   - Symbol name: Uses public symbol without `\01` prefix when optimization enabled
   ```cpp
   bool UseNilCheckThunk = CGM.shouldHaveNilCheckThunk(OMD);
   
   auto Name = getSymbolNameForMethod(OMD, false, 
                                      /*includePrefixByte*/ !UseNilCheckThunk);

   Fn = llvm::Function::Create(MethodTy, llvm::GlobalValue::ExternalLinkage,
                               Name, &CGM.getModule());
   ```

5. **Modified GenerateDirectMethodPrologue()** (CGObjCMac.cpp):
   - Skips nil-check generation when optimization is enabled
   - **Keeps class initialization** (`[self self]` for class methods) - needed even for non-null receivers because non-null ≠ initialized
   ```cpp
   // Skip nil checks when optimization is enabled
   if (ReceiverCanBeNull && !CGM.shouldHaveNilCheckThunk(OMD)) {
     // ... generate nil check code
   }
   ```

6. **Updated visibility settings** (CGObjC.cpp):
   - Direct methods use **public visibility** instead of hidden when optimization enabled
   ```cpp
   if (!CGM.shouldHaveNilCheckThunk(OMD))
     Fn->setVisibility(llvm::Function::HiddenVisibility);
   ```

7. **Added comprehensive test for variadic exclusion** (direct-method-nil-check-thunk-varargs.m):
   - Verifies variadic methods maintain old behavior (hidden linkage + nil checks)

**Key design decisions:**
- **Variadic functions excluded**: Per RFC, variadic functions keep old behavior
- **NeXT family only**: Only NeXT runtime family is supported (checked via `isNeXTFamily()`)
- **Class init stays in implementation**: For class methods, `[self self]` remains in the implementation because:
  - Non-null receiver ≠ initialized class
  - Direct calls from provably non-null sites (Phase 4) would miss initialization otherwise
  - This is a method semantic, not a nil-check concern
- **External linkage for implementations**: Makes the true implementation publicly visible and callable across TUs
- **LinkOnceODR for thunks** (Phase 3): Allows linker to deduplicate identical thunks generated by multiple callers

**Test results:**
- ✅ All existing direct-method tests pass (no regressions)
- ✅ Backward compatibility test passes (flag disabled)
- ✅ Variadic function exclusion test passes
- ⏸️ Main optimization test XFAIL'd (waiting for Phases 2-6)

### Phase 2: Implement Call Site Analysis ✅ **COMPLETED**
**Files modified:**
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CodeGenModule.h`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp`

**Changes implemented:**

1. **Added nullability analysis helper function** (CodeGenModule.h/cpp):
   ```cpp
   bool CodeGenModule::isObjCReceiverNonNull(const Expr *receiverExpr,
                                              CodeGenFunction &CGF) const {
     // Returns true if receiver is provably non-null at compile time
   }
   ```

2. **Implemented three nullability checks**:
   - **`_Nonnull` attribute check**: Uses `QualType::getNullability()` to check for explicit non-null annotations
     ```cpp
     if (auto Nullability = type->getNullability()) {
       if (*Nullability == NullabilityKind::NonNull)
         return true;
     }
     ```

   - **`self` parameter check**: Detects if receiver is the `self` parameter in an instance method
     ```cpp
     if (auto declRef = dyn_cast<DeclRefExpr>(receiverExpr)) {
       if (auto PD = dyn_cast<ImplicitParamDecl>(declRef->getDecl())) {
         if (auto OMD = dyn_cast_or_null<ObjCMethodDecl>(CGF.CurCodeDecl)) {
           if (OMD->getSelfDecl() == PD && OMD->isInstanceMethod())
             return true;
         }
       }
     }
     ```

   - **Class object check**: Identifies if receiver is a Class object (never null after initialization)
     ```cpp
     if (type->isObjCClassType() || type->isObjCQualifiedClassType())
       return true;
     ```

3. **Future enhancements** (marked as TODO):
   - Detect results of `alloc`, `new`, etc. (guaranteed non-null)
   - Detect ObjC literals (`@"string"`, `@42`, etc.)
   - Detect results of methods known to return non-null

**Key design decisions:**
- Uses existing AST APIs (`getNullability()`, `isObjCClassType()`, etc.)
- Checks `ImplicitParamDecl` for `self` (not `ParmVarDecl`)
- Handles `IgnoreParenCasts()` to look through parentheses and casts
- Conservative approach: returns `false` unless definitively non-null

**Test results:**
- ✅ Builds successfully with no compilation errors
- ✅ Ready for integration in Phase 4 (call site logic)
- ⏸️ Not yet exercised by tests (waiting for Phases 3-4)

### Phase 2.5: Fix Linkage for True Implementation ✅ **COMPLETED**
**Problem identified:**
After reviewing the RFC design document and Phase 1 implementation, the linkage type for direct method implementations was incorrect.

**The Issue:**
Phase 1 initially implemented:
```cpp
// Lines 3892-3896: INCORRECT
llvm::GlobalValue::LinkageTypes Linkage =
    UseNilCheckThunk ? llvm::GlobalValue::LinkOnceODRLinkage
                     : llvm::GlobalValue::ExternalLinkage;
```

This was **reversed** from the RFC specification:
- RFC specifies: "Linkage: **external**. This is necessary to prevent duplicated symbols during linking if the method is implemented in the header and included by multiple sources."
- **True implementations** should have `ExternalLinkage` (publicly visible across TUs)
- **Thunks** (Phase 3) should have `LinkOnceODRLinkage` (for linker deduplication)

**Files modified:**
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp`

**Changes implemented:**

1. **Reverted GenerateDirectMethod() to use ExternalLinkage** (CGObjCMac.cpp, lines 3892-3912):
   ```cpp
   // Keep UseNilCheckThunk for symbol naming and visibility control
   bool UseNilCheckThunk = CGM.shouldHaveNilCheckThunk(OMD);
   
   // Removed the Linkage variable - always use ExternalLinkage
   
   if (OldFn) {
     Fn = llvm::Function::Create(MethodTy, llvm::GlobalValue::ExternalLinkage,
                                 "", &CGM.getModule());
     Fn->takeName(OldFn);
     OldFn->replaceAllUsesWith(Fn);
     OldFn->eraseFromParent();
     I->second = Fn;
   } else {
     auto Name = getSymbolNameForMethod(OMD, /*include category*/ false,
                                        /*includePrefixByte*/ !UseNilCheckThunk);
   
     Fn = llvm::Function::Create(MethodTy, llvm::GlobalValue::ExternalLinkage,
                                 Name, &CGM.getModule());
     DirectMethodDefinitions.insert(std::make_pair(COMD, Fn));
   }
   ```

**Rationale:**
- The **original implementation was correct** with `ExternalLinkage`
- True implementations need external linkage to be publicly visible and callable from other TUs
- This is the whole point of the optimization: expose the implementation symbol
- When optimization is enabled, the changes are:
  1. Symbol name (no `\01` prefix) ✓
  2. Visibility (public instead of hidden) ✓
  3. Nil check removal (in `GenerateDirectMethodPrologue`) ✓
  4. Linkage remains `ExternalLinkage` for both modes ✓
- Thunks (Phase 3) will use `LinkOnceODRLinkage` because multiple callers may generate identical thunks

**Impact:**
- Corrects the implementation to match RFC specification
- Ensures true implementations are properly exposed across translation units
- Prepares for Phase 3 where thunks will use LinkOnceODR linkage

**Test results:**
- ✅ All existing tests continue to pass
- ✅ Implementation now correctly uses ExternalLinkage
- ✅ Ready for Phase 3 (thunk generation with LinkOnceODR linkage)

### Phase 3: Implement Thunk Generation
**Files to modify:**
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp`
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CodeGenModule.h/cpp`

**Changes:**
1. Create a new function to generate thunks:
```cpp
llvm::Function* generateObjCDirectThunk(
    const ObjCMethodDecl *OMD,
    llvm::Function *trueImplementation) {
  // Create thunk function with name: methodName + "_thunk"
  // Linkage: LinkOnceODRLinkage
  // Body:
  //   - Check if self == null
  //   - If null: return zero-initialized value
  //   - If not null: musttail call to trueImplementation
}
```

2. Thunk structure:
```llvm
define linkonce_odr i32 @"-[Class method]_thunk"(ptr %self, ptr %_cmd, ...) {
entry:
  %is_nil = icmp eq ptr %self, null
  br i1 %is_nil, label %nil_case, label %non_nil_case

nil_case:
  ret i32 0  ; or appropriate zero value for return type

non_nil_case:
  %result = musttail call i32 @"-[Class method]"(ptr %self, ptr %_cmd, ...)
  ret i32 %result
}
```

3. Cache generated thunks to avoid duplicates within a module

### Phase 4: Integrate Call Site Logic
**Files to modify:**
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjC.cpp`

**Changes:**
1. In call emission code:
```cpp
if (CGM.getCodeGenOpts().ObjCNilCheckThunk &&
    method->isDirectMethod()) {
  if (isReceiverDefinitelyNonNull(receiverExpr, *this)) {
    // Direct call to true implementation
    callee = trueImplementation;
  } else {
    // Call the thunk (create if needed)
    callee = getOrCreateThunk(method);
  }
} else {
  // Old behavior
}
```

### Phase 5: Handle Special Cases
**Considerations:**
1. **Variadic functions:** Per RFC, skip optimization (continue with old behavior)
2. **Class methods:** Treat as non-null after `[self self]` call
3. **ARC compatibility:** Ensure thunk preserves ARC semantics with musttail
4. **Attributes propagation:** Copy relevant attributes from implementation to thunk

### Phase 6: Update Tests
**Files to modify:**
- `/home/peterrong/llvm-project/clang/test/CodeGenObjC/direct-method-nil-check-thunk.m`

**Changes:**
Update CHECK lines to expect:
- `linkonce_odr` linkage
- No `\01` prefix on symbols
- No nil checks in implementations
- Thunk generation for nullable receivers
- Direct calls for non-null receivers

## Testing Strategy
1. Run existing objc_direct tests to ensure no regressions
2. Test with `-fobjc-nil-check-thunk` flag enabled
3. Test without flag to ensure backward compatibility
4. Test various scenarios:
   - Instance methods
   - Class methods
   - Properties
   - Methods with various return types (primitives, structs, objects)
   - Non-null vs nullable receivers
   - Variadic methods (should use old behavior)

## Build and Validation
```bash
# Build clang
ninja -C build-debug clang

# Run tests
ninja -C build-debug check-clang-codegen-objc

# Run specific test
./build-debug/bin/llvm-lit -v clang/test/CodeGenObjC/direct-method-nil-check-thunk.m
```

## Code References
Key files and functions:
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:3900-3998` - StartObjCMethod (nil check generation)
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjC.cpp:744-802` - StartObjCMethod and GenerateObjCMethod
- `/home/peterrong/llvm-project/clang/lib/CodeGen/CGObjC.cpp` - Message send emission

## Notes
- This is a significant optimization affecting ABI and code generation
- Requires careful attention to ARC semantics
- Must preserve backward compatibility
- Thunks use `musttail` to maintain ARC optimization opportunities
- `linkonce_odr` ensures proper deduplication across translation units
